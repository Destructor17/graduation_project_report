Существует множество программных библиотек, предоставляющих возможность выполнить код WebAssembly с помощью интерпретации или JIT-компиляции.
Одним из самых популярных решений является Wasmer.

Wasmer написан на языке программирования Rust и предоставляет возможность выполнять код WebAssembly с помощью JIT-компиляции.
Для JIT-компиляции может быть использована одна из трёх библиотек: LLVM, Cranelift и Singlepass.
Так как Singlepass не обеспечивает высокой производительности, а LLVM требует большого количества времени для компиляции \cite{WasmerRuntimes} и значительно увеличивает размер приложения, Cranelift является оптимальным решением.
В рамках дипломного проекта Wasmer и Cranelift используются на ОС Windows, Linux и Android.

Так как многие другие программные библиотеки для JIT-компиляции, включая Cranelift, не поддерживает 32-х битные архитектуры процессоров, разрабатываемая среда выполнения кода должна также поддерживать интерпретаторы.
Один из самых производительных интерпретаторов предоставляет программная библиотека WAMR.
Тогда как WAMR предоставляет несколько конфигураций, нас интересует конфигурация Fast Interpreter.
Эта конфигурация используется на 32-х битных устройствах под управлением Android, тогда как в 64-х битных используется Wasmer и Cranelift.

MacOS и iOS имеют предустановленную программную библиотеку JavaScriptCore.
JavaScriptCore предназначен в первую очередь для выполнения кода на языке программирования JavaScript, но, так как JavaScriptCore используется в веб-браузере Safari, он также поддерживает выполнение кода WebAssembly.
JavaScriptCore использует интерпретацию и JIT-компиляцию одновременно, что обеспечивает хорошую производительность и скорость запуска.
Так как JavaScriptCore уже предустановлена, его использование уменьшает размер приложения и сложность сборки.
Wasmer может использовать JavaScriptCore вместо программных библиотек для JIT-компиляции.
Всё это делает использование Wasmer и JavaScriptCore разумным решением в рамках операционных систем MacOS и iOS.

Так как в некоторых версиях iOS JavaScriptCore не поддерживает WebAssembly \cite{JSCNoWasm}, следует добавить проверку поддержки WebAssembly в начале работы приложения для iOS.
Если WebAssembly не поддерживается, следует использовать другой подход к выполнению кода.
Так как iOS не позволяет использовать JIT-компиляцию, следует использовать интерпретатор.
WAMR имеет плохую поддержку iOS, поэтому в создаваемой среде выполнения кода будет использована программная библиотека WASM3.
WASM3 проста в компиляции и предоставляет производительный интерпретатор кода WebAssembly.

Так как современные веб-браузеры имеют поддержку WebAssembly API \cite{WasmBrowserSupport}, его использование для данной платформы целесообразно.
По этой причине в разрабатываемую среду выполнения кода добавлена возможность выполнять код, используя WebAssembly API.

Веб-браузеры требуют асинхронного, неблокирующего выполнения кода. 
Это значит, что в выполнение кода должно быстро завершаться и начинаться заново при таких событиях, как нажатие клавиши, кнопки мыши или касание.
До тех пор, пока выполняется код, содержимое страницы не может быть обновлено.
Так как многие приложения являются синхронными и могут работать в течении продолжительного промежутка времени, пользователь не сможет взаимодействовать с такими программами во время их выполнения.
Emscripten, с помощью которого происходит компиляция разрабатываемой среды выполнения для веб-браузеров, имеет функционал, позволяющий асинхронно выполнять код, в то время как WebAssembly API сам по себе такого функционала не имеет.

Эта проблема может быть решена с использованием Web Worker.
Web Worker позволяет выполнять код параллельно с основной частью программы, не блокируя её выполнение.
Web Worker обменивается информацией с основной частью программы с помощью сообщений \cite{WebWorkerMessages}.
Для выполнения кода с помощью WebAssembly API создаётся Web Worker, который получает сообщение от основной части программы, содержащее код приложения, после чего начинает его выполнение.
Во время выполнения кода приложения Web Worker может отправлять сообщения основной части программы, но не может их получать, так как получение сообщений является асинхронным.
Поэтому, когда приложение вызывает импортируемую функцию, основной части программы отправляется сообщение с идентификатором вызванной функции и её аргументами, а результат работы функции передаётся обратно в Web Worker с помощью SharedArrayBuffer и Atomics.

SharedArrayBuffer является объектом, ссылающимся на двоичные данные.
Два объекта SharedArrayBuffer могут ссылаться на одни и те же данные, даже если один из них находится в основной части программы, а второй -- в Web Worker.
Из-за существования уязвимости Spectre, создание объекта SharedArrayBuffer требует соблюдения условий, обеспечивающих достаточный уровень безопасности и конфиденциальности \cite{SharedArrayBuffer}. В большинстве случаев достаточно добавить следующие HTTP-заголовочники:

-- ~Cross-Origin-Opener-Policy со значением same-origin;

-- ~Cross-Origin-Embedder-Policy со значением require-corp.

Atomics предоставляет некоторые методы для работы с SharedArrayBuffer.
В рамках дипломного проекта использованы методы Atomics.wait и Atomics.notify.
Atomics.wait вызывается в Web Worker при ожидании ответа на сообщение о вызове импортируемой функции.
Atomics.notify вызывается в основной части программы сразу после того, как в объект SharedArrayBuffer записан результат выполнения функции, и уведомляет Web Worker о получении результата.

